#!/bin/bash

# Copyright (c) 2019 M. Isaac Holger <isaac@paralleltheory.com> / Parallel Theory LLC
# All rights reserved.

# TODO: [20191107] inherit global consul config from theory when terraform backend specifies consul but doesn't provide config (more procedurally, support inheriting global service configs where implementation requires but doesn't specify discrete parameters)
# TODO: [20191107] allow ".vars" interpolation to support resolving values via child theorycraft calls
# TODO: [20191108] add mysql - this is probably less of a fit, but there are processes we frequently run which could see an increase in efficiency via automation
# TODO: [20191108] fix mysql to support multiple database definitions. and/or my.cnf...

options_usage() {
    echo "Options:"
    echo "    -t,--theory <name>        Selects the named configuration within the theories folder"
}

usage() {
    if [ "${APP}" == "" ]
    then
        APP="<app>"
        common_cmds="
Supported Apps:
    new
    terraform
    consul
    vault
    packer
    git
    
    (for more detailed help, try '$0 <app> help')"
    fi

    echo "Usage: $0 [options] ${APP} <command> [args]"
    echo "${common_cmds}"
    if [ -n "$(type -t ${APP}_usage)" ] && [ "$(type -t ${APP}_usage)" = function ]
    then
        ${APP}_usage
    fi
    echo ""; options_usage; echo ""
    exit 1
}

new_usage() {
    echo "To create a new universe, please specify a new universe name."
    echo "Specifying '-t' will create the named theory within the specified universe, eg:"
    echo "    $0 new my_universe"
    echo "    $0 -t new_theory new my_universe"
    echo ""
    echo "If called from within an existing universe, simply provide the a new theory name:"
    echo "    $0 new new_theory"
    echo "Alternatively, '-t' syntax works here as well:"
    echo "    $0 -t new_theory new"
}

terraform_usage() {
    tf_usage
}

tf_usage() {
    echo "Terraform Commands:"
    echo "    init"
    echo "    plan"
    echo "    apply"
    echo "    destroy"
    echo "    fmt"
    echo "    validate"
}

vault_usage() {
    echo "Vault Commands:"
    echo "    login"
    echo "    seal"
    echo "    unseal"
}

packer_usage() {
    echo "Packer Commands:"
    echo "    build"
    echo "    inspect"
    echo "    validate"
}

consul_usage() {
    echo "Consul Commands:"
    echo "    acl"
    echo "    kv"
    echo ""
    echo "Consul kv Subcommands:"
    echo "    get"
    echo "    put"
    echo "    del"
    echo ""
    echo "Consul Parameters:"
    echo "    -d,--dc <name>            Selects the datacenter to run consul queries against"
    echo "    --token <token>           Override consul token from current theory"
}

mysql_usage() {
    echo "MySQL Commands:"
    echo "    backup"
}

git_usage() {
    echo "Git Commands:"
    echo "    sync"
    echo ""
    echo "Git Sync:"
    echo "    Examines the structure of the 'git' folder and attempts to fetch or clone matching repositories."
    echo "    eg: Given the .git.address value of 'ssh://git@gitlab.mydomain.com' in the active theory,"
    echo "        the folder 'git/terraform/custom_module' would attempt to clone (or fetch, as apropros):"
    echo "        ssh://git@gitlab.mydomain.com/terraform/custom_module.git"
}

loadTheory() {
    THEORY=$1

    FNAME="theories/${THEORY}.json"
    VARSFNAME="theories/${THEORY}.vars"

    if [ -f "${FNAME}" ]
    then
        # .terraform.backend s3 requires .aws, bucket
        # .terraform.backend consul requires consul

        # .aws requires profile
        # .consul requires host, port, token

        # i have no idea (yet) how azure or gcp work ...
        
        theoryjson=$(cat "${FNAME}")

        if [ -f "${VARSFNAME}" ]
        then
            for var in $(cat "${VARSFNAME}")
            do
                __KEY=$(echo ${var} | cut -d: -f1)
                __VAL=$(echo ${var} | cut -d: -f2-)
                theoryjson=$(echo "${theoryjson}" | sed -e "s/%${__KEY}%/${__VAL}/g")
            done
        fi

        awsjson=$(echo "${theoryjson}" | jq -r ".aws")
        azurejson=$(echo "${theoryjson}" | jq -r ".azure")
        gcpjson=$(echo "${theoryjson}" | jq -r ".gcp")

        terraformjson=$(echo "${theoryjson}" | jq -r ".terraform")
        consuljson=$(echo "${theoryjson}" | jq -r ".consul")
        vaultjson=$(echo "${theoryjson}" | jq -r ".vault")
        mysqljson=$(echo "${theoryjson}" | jq -r ".mysql")
        gitjson=$(echo "${theoryjson}" | jq -r ".git")

        if [ "${vaultjson}" != "null" ]
        then
            TC_VAULT_ADDR=$(echo "${vaultjson}" | jq -r ".address")
            TC_VAULT_SKIP_VERIFY=$(echo "${vaultjson}" | jq -r ".skip_verify")

            if [ "${TC_VAULT_ADDR}" != "null" ]
            then
                TC_HAS_VAULT=true
                export VAULT_ADDR="https://${TC_VAULT_ADDR}"

                if [ "${TC_VAULT_SKIP_VERIFY}" != "null" ]
                then
                    export VAULT_SKIP_VERIFY="${TC_VAULT_SKIP_VERIFY}"
                fi
            fi
        fi

        if [ "${awsjson}" != "null" ]
        then
            TC_AWS_PROFILE=$(echo "${awsjson}" | jq -r ".profile")
            if [ "${TC_AWS_PROFILE}" != "null" ]
            then
                TC_HAS_AWS=true
            fi
        fi

        if [ "${terraformjson}" != "null" ]
        then
            TC_TERRAFORM_BACKEND=$(echo "${terraformjson}" | jq -r ".backend")
            terraformbackendjson=$(echo "${terraformjson}" | jq -r ".${TC_TERRAFORM_BACKEND}_config")

            if [ "${TC_TERRAFORM_BACKEND}" != "null" ]
            then
                TC_HAS_TERRAFORM=true
            fi
        fi

        if [ "${mysqljson}" != "null" ]
        then
            TC_MYSQL_PROFILES=$(echo "${mysqljson}" | jq -r ".profiles")

            if [ "${TC_MYSQL_PROFILES}" != "null" ]
            then
                export TC_HAS_MYSQL=true
            fi
        fi

        if [ "${gitjson}" != "null" ]
        then
            TC_GIT_TARGET=$(echo "${gitjson}" | jq -r ".address")

            if [ "${TC_GIT_TARGET}" != "null" ]
            then
                export TC_HAS_GIT=true
            fi
        fi

        if [ "${TC_TERRAFORM_BACKEND}" == "s3" ] && [ "${TC_HAS_AWS}" == "true" ]
        then
            # setup s3...
            TC_TERRAFORM_BACKEND_CONFIG="-backend-config"
        elif [ "${TC_TERRAFORM_BACKEND}" == "s3" ] && [ "${TC_HAS_AWS}" != "true" ]
        then
            echo "Theory requires .terraform.backend:s3 but doesn't describe .aws"
            exit 1
        fi

        if [ "${consuljson}" != "null" ]
        then
            TC_CONSUL_ADDRESS=$(echo "${consuljson}" | jq -r ".address")
            TC_CONSUL_TOKEN=$(echo "${consuljson}" | jq -r ".token")

            if [ "${TC_CONSUL_ADDRESS}" != "null" ] && [ "${TC_CONSUL_TOKEN}" != "null" ]
            then
                export TC_HAS_CONSUL=true
                export CONSUL_HTTP_ADDR=${TC_CONSUL_ADDRESS}
                export CONSUL_HTTP_TOKEN=${TC_CONSUL_TOKEN}
            fi
        fi
    else
        echo "$0: Couldn't read theory from '${FNAME}'; cowardly giving up!"
        exit 2
    fi
}

newProject() {
    PROJ=$1
    shift
    
    THEORIES="${PROJ}/theories"
    FNAME="${THEORIES}/${THEORY}.json"

    if [ -f "${FNAME}" ]
    then
        echo "That project already has a '${THEORY}' theory."
        exit 1
    elif [ -d "${THEORIES}" ]
    then
        echo "Project '${PROJ}' exists, crafting a new theory '${THEORY}'"
        newTheory ${THEORY} ${PROJ}
        exit 0
    elif [ -d "${PROJ}" ]
    then
        echo "Project folder '${PROJ}' exists, but isn't for theorycrafting."
        exit 3
    else
        echo "Crafting project '${PROJ}', and theory '${THEORY}'."
        newSkeleton ${PROJ}
        newTheory ${THEORY} ${PROJ}
    fi
}

newSkeleton() {
    PROJ=$1
    shift

    mkdir -p ${PROJ}
    mkdir -p ${PROJ}/theories
    mkdir -p ${PROJ}/terraform
    mkdir -p ${PROJ}/packer
    mkdir -p ${PROJ}/docker
    mkdir -p ${PROJ}/playbooks

    newGitIgnore ${PROJ}
    newReadme ${PROJ}
}

newTheory() {
    THEORY=$1
    shift
    FNAME="theories/${THEORY}.json"
    if [[ "$1" != "" ]] && [[ -d "$1/theories" ]]
    then
        FNAME="$1/${FNAME}"
    fi

    cat <<EOF > ${FNAME}
{
    "aws": {
        "profile": "default"
    },
    "terraform": {
        "backend": "s3",
        "s3_config": {
            "bucket": "terraform"
        },
        "consul_config": {
            "address": "consul.paralleltheory.lan:8500",
            "state_path": "terraform/${PROJ}"
        }
    },
    "consul": {
        "address": "consul.paralleltheory.lan:8500",
        "token": "..."
    },
    "vault": {
        "address": "vault.paralleltheory.lan:8200"
    },
    "mysql": {
        "database": {
            "credentials": "mysql_config_editor_path",
            "host": "db.paralleltheory.lan"
        }
    }
}
EOF
}

newGitIgnore() {
    PROJ=$1
    shift

    cat <<EOF > ${PROJ}/.gitignore
### THEORYCRAFT
**/theories/*.vars
git/**

### TERRAFORM
# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log

# Ignore any .tfvars files that are generated automatically for each Terraform run. Most
# .tfvars files are managed as part of configuration and so should be included in
# version control.
#
# example.tfvars

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Include override files you do wish to add to version control using negated pattern
#
# !example_override.tf

# Include tfplan files to ignore the plan output of command: terraform plan -out=tfplan
# example: *tfplan*

### PACKER
# Cache objects
packer_cache/

# For built boxes
*.box

### ANSIBLE
*.retry

EOF
}

newReadme() {
    PROJ=$1
    shift

    cat <<EOF > ${PROJ}/README.md

${PROJ}
============

Introduction
------------

Spend a little time here descriving what this project is all about, and what your theory is


Authors
-------

Who are you? How do we get ahold of you?


License
-------

If you offer one ...


Copyright
---------

Because you need one.



EOF
}

gitsync() {
    GIT_PATH=$1
    shift

    X_CONTENTS_PATH=$1
    shift

    cd ${GIT_PATH}
    for x in *
    do
        echo "Looking at ${X_CONTENTS_PATH}/${x}"
        if [ -d "${x}" ]
        then
            if [ ! -d "${x}/.git" ]
            then
                X_CONTENTS=$(ls -1 ${x} | wc -l)
                if [ "${X_CONTENTS}" == "0" ]
                then
                    echo -n "Empty folder, attempting sync..."
                    rmdir ${x}
                    git clone ${TC_GIT_TARGET}${X_CONTENTS_PATH}/${x}.git ${x} >/dev/null 2>&1
                    if [ $? -ne 0 ]
                    then
                        echo "sync failed, replacing placeholder."
                        mkdir ${x}
                    fi
                else
                    gitsync ${x} ${X_CONTENTS_PATH}/${x}
                fi
            else
                echo -n "Looks like a git repo, running 'git fetch'..."
                cd ${x}
                git fetch >/dev/null 2>&1
                if [ $? -eq 0 ]
                then
                    echo "success!"
                else
                    echo "something went awry."
                fi
                cd ..
            fi
        fi
    done
    cd ..
    X_CONTENTS_PATH=$(dirname ${X_CONTENTS_PATH})
}

THEORY="default"

while ([[ $# -gt 2 ]] && [[ "$1" == "-"* ]]) || ([[ $# -gt 0 ]] && [[ "$1" == "new" ]])
do
    opt="$1"
    shift
    case "${opt}" in
        -t|--theory)
            THEORY=$1
            shift
            ;;
        new)
            if [ -d "./theories" ]
            then
                echo "new theory $1"
                if [ "${THEORY}" == "default" ] && [ "$1" != "" ]
                then
                    newTheory $1
                elif [ "$1" == "" ] && [ "${THEORY}" != "default" ]
                then
                    newTheory ${THEORY}
                else
                    echo "This should never happen."
                fi
            else
                newProject $1
            fi
            shift
            exit 0
            ;;
    esac
done

APP=$1
shift

loadTheory "${THEORY}"

case ${APP} in
    terraform|tf)
        if [ "${TC_HAS_TERRAFORM}" != "true" ]
        then
            echo "Theory doesn't describe terraform."
            exit 2
        fi

        CMD=$1
        shift
        case ${CMD} in
            new)
                echo "new"
                ;;
            plan)
                ;;
            apply)
                ;;
            destroy)
                ;;
            validate)
                ;;
            fmt)
                ;;
            help|*)
                usage
                ;;
        esac
        ;;
    consul)
        if [ "${TC_HAS_CONSUL}" != "true" ]
        then
            echo "${THEORY} doesn't describe consul"
            break
        fi

        # FIXME: [20191107] fix consul QRYSUFFIX when datacenter comes from theory
        QRYSUFFIX="?pretty"
        XDATA=""
        while [[ $# -gt 1 ]] && [[ "$1" == "-"* ]]
        do
            opt="$1"
            shift
            case "${opt}" in
                -d|--dc)
                    CONSUL_DC=$1
                    shift
                    QRYSUFFIX="${QRYSUFFIX}&dc=${CONSUL_DC}"
                    ;;
                --token)
                    TC_CONSUL_TOKEN=$1
                    shift
                    ;;
            esac
        done

        CMD=$1
        shift

        case ${CMD} in
            kv)
                #consul ${CMD} $*
                MODE=$1
                shift

                KVPATH=$1
                shift

                case ${MODE} in
                    list)
                        XMODE="GET"
                        QRY="${KVPATH}${QRYSUFFIX}&keys"
                        ;;
                    get)
                        XMODE="GET"
                        QRY="${KVPATH}${QRYSUFFIX}"
                        ;;
                    # TODO: [20191108] fix the shit out of XDATA.
                    put)
                        XMODE="PUT"
                        QRY="${KVPATH}${QRYSUFFIX}"
                        XDATA="--data $1"
                        shift
                        ;;
                    del)
                        XMODE="DELETE"
                        QRY="${KVPATH}${QRYSUFFIX}"
                        ;;
                esac

                curl -s -X${XMODE} -H "X-Consul-Token: ${TC_CONSUL_TOKEN}" "http://${TC_CONSUL_ADDRESS}/v1/kv/${QRY}" ${XDATA}
                ;;
            acl)
                consul ${CMD} $*
                ;;
            api)
                curl -s -XGET -H "X-Consul-Token: ${TC_CONSUL_TOKEN}" "http://${TC_CONSUL_ADDRESS}/v1/$*"
                ;;
            help|*)
                usage
                ;;
        esac
        ;;
    vault)
        if [ "${TC_HAS_VAULT}" != "true" ]
        then
            echo "Theory doesn't describe vault."
            exit 2
        fi

        CMD=$1
        shift
        case ${CMD} in
            login)
                vault login
                ;;
            get)
                if [ $# -ne 2 ]
                then
                    usage
                fi

                __VAULT_PATH=$1
                __VAULT_FIELD=$2
                shift; shift;

                vault kv get -field $__VAULT_FIELD $__VAULT_PATH
                ;;
            put)
                ;;
            help|*)
                usage
                ;;
        esac
        ;;
    packer)
        CMD=$1
        shift
        case ${CMD} in
            build)
                ;;
            inspect)
                ;;
            validate)
                ;;
            help|*)
                usage
                ;;
        esac
        ;;
    ansible)
        CMD=$1
        shift
        ;;
    mysql)
        if [ "${TC_HAS_MYSQL}" != "true" ]
        then
            echo "Theory doesn't describe MySQL"
            exit 1
        fi

        CMD=$1
        shift
        case ${CMD} in
            backup)
                profile=$1
                shift

                if [ ! -d "./backups" ]
                then
                    echo "Couldn't find local backup destination within this universe."
                    exit 2
                fi
                DATESTR=$(date +'%Y%m%d')
                ITERATION=$(printf "%02d" $(( $(ls -laF backups/$1.$2.${DATESTR}-*.sql 2>/dev/null | wc -l)+1 )))
                
                TC_MYSQL_PROFILE=$(echo "${TC_MYSQL_PROFILES}" | jq -r ".${profile}.credentials")
                TC_MYSQL_HOST=$(echo "${TC_MYSQL_PROFILES}" | jq -r ".${profile}.host")
                mysqldump --login-path=${TC_MYSQL_PROFILE} -h ${TC_MYSQL_HOST} $1 $2 > backups/$1.$2.${DATESTR}-${ITERATION}.sql
                ;;
            connect)
                profile=$1
                shift

                TC_MYSQL_PROFILE=$(echo "${TC_MYSQL_PROFILES}" | jq -r ".${profile}.credentials")
                TC_MYSQL_HOST=$(echo "${TC_MYSQL_PROFILES}" | jq -r ".${profile}.host")
                mysql --login-path=${TC_MYSQL_PROFILE} -h ${TC_MYSQL_HOST}
                ;;
        esac
        ;;
    git)
        if [ "${TC_HAS_GIT}" != "true" ]
        then
            echo "Theory doesn't describe Git"
            exit 1
        fi

        CMD=$1
        shift
        case ${CMD} in
            sync)
                gitsync git
                ;;
        esac
        ;;
    *)
        usage
        ;;
esac
